<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>景区搜索</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 960px; margin: 20px auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #333; margin-bottom: 25px; }
        .controls { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 25px; padding: 20px; background-color: #eef; border-radius: 5px; }
        .controls > div { display: flex; flex-direction: column; flex: 1; min-width: 180px; }
        .controls label { margin-bottom: 8px; font-weight: bold; font-size: 0.9em; color: #555; }
        .controls input[type="text"],
        .controls select { padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em; }
        .spots-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px; list-style: none; padding: 0; }
        .spots-grid li { background-color: #fff; border: 1px solid #eee; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.08); transition: transform 0.2s ease; }
        .spots-grid li:hover { transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .spots-grid img { width: 100%; height: 180px; object-fit: cover; display: block; }
        .spot-info { padding: 15px; }
        .spot-info h3 { margin: 0 0 10px 0; font-size: 1.2em; color: #333; }
        .spot-info p { margin: 5px 0; font-size: 0.9em; color: #666; }
        .spot-info .score { font-weight: bold; color: #e67e22; }
        .spot-info .type { background-color: #e7f5ff; color: #228be6; padding: 3px 8px; border-radius: 12px; display: inline-block; font-size: 0.8em; }
        .loading, .no-results { text-align: center; padding: 30px; color: #888; font-size: 1.1em; grid-column: 1 / -1; /* Span across all columns if grid is empty */}
    </style>
</head>
<body>

<div class="container">
    <h1>探索景区</h1>

    <div class="controls">
        <div>
            <label for="search-keyword">关键词搜索:</label>
            <input type="text" id="search-keyword" placeholder="输入景区名称...">
        </div>
        <div>
            <label for="filter-type">按类型筛选:</label>
            <select id="filter-type">
                <option value="">所有类型</option>
                <!-- 类型选项将动态加载 -->
            </select>
        </div>
        <div>
            <label for="sort-by">排序方式:</label>
            <select id="sort-by">
                <option value="default">默认排序</option>
                <option value="popularity_desc">热度 高 → 低</option>
            </select>
        </div>
    </div>

    <ul id="spots-list" class="spots-grid">
        <li class="loading">正在加载景区数据...</li>
    </ul>
    <div id="no-results" class="no-results" style="display: none;">抱歉，没有找到符合条件的景区。</div>

</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const searchInput = document.getElementById('search-keyword');
        const typeFilter = document.getElementById('filter-type');
        const sortBy = document.getElementById('sort-by');
        const spotsList = document.getElementById('spots-list');
        const noResultsDiv = document.getElementById('no-results');

        const spotTypes = [
            "历史建筑", "赏花胜地", "萌萌动物", "城市漫步", "夜游观景",
            "遛娃宝藏地", "展馆展览", "地标观景", "登高爬山", "踏青必去",
            "自然山水", "游乐场", "演出"
        ];

        // 填充类型筛选下拉框
        spotTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            typeFilter.appendChild(option);
        });
        
        // 解析URL参数，并设置对应的筛选条件
        function parseUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const keywordParam = urlParams.get('keyword');
            const typeParam = urlParams.get('type');
            
            if (keywordParam) {
                searchInput.value = keywordParam;
            }
            
            if (typeParam && spotTypes.includes(typeParam)) {
                typeFilter.value = typeParam;
            }
            
            // 加载URL参数后立即获取数据
            fetchAndDisplaySpots();
        }

        // 获取并显示景点数据 (根据当前筛选和排序条件)
        function fetchAndDisplaySpots() {
            spotsList.innerHTML = '<li class="loading">正在加载景区数据...</li>'; // 显示加载提示
            noResultsDiv.style.display = 'none';

            // 1. 获取当前筛选和排序参数
            const keyword = searchInput.value.trim();
            const selectedType = typeFilter.value;
            const sortValue = sortBy.value;

            // 2. 构建 API 请求 URL (带查询参数)
            // *** 确保后端有 /api/search-spots 接口来处理这些参数 ***
            const apiUrl = new URL('/api/search-spots', window.location.origin); // 使用相对路径构建
            if (keyword) {
                apiUrl.searchParams.append('keyword', keyword);
            }
            if (selectedType) {
                apiUrl.searchParams.append('type', selectedType);
            }
            if (sortValue !== 'default') {
                apiUrl.searchParams.append('sort_by', sortValue);
            }

            // 3. 发送请求
            fetch(apiUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // 4. 处理响应并显示结果
                    if (data.success && Array.isArray(data.spots)) {
                        displaySpots(data.spots);
                    } else {
                        spotsList.innerHTML = '<li class="loading">加载景点数据失败或格式错误。</li>';
                        console.error('获取景点数据失败:', data.message || '格式错误');
                        displaySpots([]); // 清空列表并可能显示无结果提示
                    }
                })
                .catch(error => {
                    spotsList.innerHTML = '<li class="loading">加载景点时出错，请检查网络或联系管理员。</li>';
                    console.error('获取搜索结果时出错:', error);
                    displaySpots([]); // 清空列表并可能显示无结果提示
                });
        }

        // 显示景点列表 (此函数基本不变)
        function displaySpots(spotsToDisplay) {
            spotsList.innerHTML = ''; // 清空当前列表
            noResultsDiv.style.display = 'none';

            if (!spotsToDisplay || spotsToDisplay.length === 0) {
                noResultsDiv.style.display = 'block';
                spotsList.innerHTML = ''; // Ensure list is empty when showing no results
                return;
            }

            spotsToDisplay.forEach(spot => {
                const li = document.createElement('li');
                const imgHtml = spot.img ? `<img src="${spot.img}" alt="${spot.name || '景区图片'}">` : '<div style="height: 180px; background: #eee; display: flex; align-items: center; justify-content: center; color: #aaa;">无图</div>';
                const name = spot.name || '未知景点';
                const score = (spot.score !== undefined && spot.score !== null) ? parseFloat(spot.score).toFixed(1) : 'N/A';
                const type = spot.type || '未知类型';
                const popularity = (spot.visited_time !== undefined && spot.visited_time !== null) ? parseInt(spot.visited_time) : 'N/A'; // 假设 visited_time 是热度

                li.innerHTML = `
                    ${imgHtml}
                    <div class="spot-info">
                        <h3><a href="/spots/spot_info/${spot.id}">${name}</a></h3> <!-- 修改这里，将名字变为链接 -->
                        <p>评分: <span class="score">${score}</span></p>
                        <p>热度: ${popularity}</p>
                        <p>类型: <span class="type">${type}</span></p>
                        ${spot.id ? `<p style="font-size: 0.8em; color: #999;">ID: ${spot.id}</p>` : ''} <!-- ID 可以保留或移除 -->
                    </div>
                `;
                spotsList.appendChild(li);

            });
        }

        // 添加事件监听器 (每次改变都重新获取数据)
        // 使用 debounce 或 throttle 优化频繁触发的 input 事件 (可选)
        let searchTimeout;
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(fetchAndDisplaySpots, 300); // 延迟 300ms 触发搜索，避免频繁请求
        });
        typeFilter.addEventListener('change', fetchAndDisplaySpots);
        sortBy.addEventListener('change', fetchAndDisplaySpots);

        // 初始加载数据 (解析URL参数并应用)
        parseUrlParameters();
    });
</script>

</body>
</html>
